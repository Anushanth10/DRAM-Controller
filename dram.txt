module dram (
input clk,
input[1:0] opcode,  
input[9:0] row,
input[9:0] column,
input[38:0] data_in,
output reg[38:0] data_out,
output reg[1:0] error,
input [7:0]temp
);
reg[38:0] mem [1023:0][1023:0]; //[row][column]
reg[2:0] current_state;
reg[2:0] next_state;
integer i;
integer j;
integer count;
reg [7:0] temp_reg;
    
parameter INITIAL =3'b000;
parameter IDLE =3'b001;
parameter READ =3'b010;
parameter WRITE =3'b011;
parameter REFRESH =3'b100;
parameter HAMMING=3'b110;

reg  [4:0] refresh_cnt; 
reg  [5:0] syndrome;
reg [38:0] hamming;     
reg [38:0] corrected_word; 
reg [38:0] word;      // counts cycles within period
reg  [4:0] period_max_reg; 
reg parity_check;        // 9  (=>10?cycles) or 19 (=>20)
reg        refresh_mode;           // 1 = adaptive, 0 = scheduled
wire       do_refresh =(refresh_cnt == period_max_reg);

always @ (posedge clk)begin
            current_state<=next_state;
            temp_reg <= temp;
            
 if (do_refresh) begin
            // Countdown finished: reset counter and capture *new* mode/period
            refresh_cnt     <= 5'd0;
            refresh_mode    <= (temp_reg > 8'd40);      // 1 = hot/adaptive
            period_max_reg  <= (temp_reg > 8'd40) ? 5'd9 : 5'd19;
        end
        else begin
            refresh_cnt <= refresh_cnt + 5'd1;
        end   
    end
always @(*) begin
        case(current_state) 
             INITIAL:
                   begin
                      $display("POWER-ON SELF-TEST SUCCESFULL");
                      $display("CONFIGURATION LOADED");
                      $display("CALLIBRATION ADJUSTED ");
                      next_state =IDLE;
                   end
             IDLE:begin
              if (do_refresh)
                    next_state = REFRESH;
              else begin
                 case(opcode) 
                 2'b01:next_state =READ;
                 2'b10:next_state =WRITE;
                 default:next_state=IDLE;
                 endcase
             end
             end
             
             READ:
               begin
                    word =mem[row][column];
                    hamming[0] = 0;  
                    hamming[1] = 0; 
                    hamming[3] = 0;  
                    hamming[7] = 0; 
                    hamming[15] = 0; 
                    hamming[31] = 0; 
                
                    hamming[2]=word[0];
                    hamming[4:6]=word[1:3];
                    hamming[8:14]=word[4:10];
                    hamming[16:30]=word[11:25];
                    hamming[32:38]=word[26:31];
                    for (i = 1; i <= 32; i = i + 1)
                    begin
                            
                            if (i & 1)      hamming[0] = hamming[0] ^ word[i-1]; // P1 checks bits where bit 0 of i is 1
                            if (i & 2)      hamming[1] = hamming[1] ^ word[i-1]; // P2 checks bits where bit 1 of i is 1
                            if (i & 4)      hamming[3] = hamming[3] ^ word[i-1]; // P4 checks bits where bit 2 of i is 1
                            if (i & 8)      hamming[7] = hamming[7] ^ word[i-1]; // P8 checks bits where bit 3 of i is 1
                            if (i & 16)     hamming[15] = hamming[15] ^ word[i-1]; // P16 checks bits where bit 4 of i is 1
                            if (i & 32)     hamming[31] = hamming[31] ^ word[i-1]; // P32 checks bits where bit 5 of i is 1
                        end
               
                 hamming[38] = ^hamming[37:0];
                syndrome[0] = hamming[0] ^ word[0];
                syndrome[1] = hamming[1] ^ word[1];
                syndrome[2] = hamming[3] ^word[3];
                syndrome[3] = hamming[7] ^ word[7];
                syndrome[4] = hamming[15] ^ word[15];
                syndrome[5] = hamming[31] ^ word[31];

                parity_check = ^word[37:0] ^ word[38];

                if (syndrome == 6'd0 && parity_check == 1'b0) begin
                      error = 2'b00;
                     data_out =word;
                     next_state =IDLE;
                end else if (syndrome != 6'd0 && parity_check == 1'b1) begin
                    word[syndrome - 1] = ~word[syndrome - 1];
                    error = 2'b01;
                    data_out=word;
                    $display("Single bit error ,corrected while reading");
                    next_state =IDLE;
                end else if (syndrome == 6'd0 && parity_check == 1'b1) begin
                    error = 2'b10;
                     $display("Double bit error ,read halted ");
                    next_state =IDLE;
                end 
                               
                end  
            WRITE:
                begin
                     hamming[0] = 0;  
                    hamming[1] = 0; 
                    hamming[3] = 0;  
                    hamming[7] = 0; 
                    hamming[15] = 0; 
                    hamming[31] = 0; 
                
                    hamming[2]=data_in[0];
                    hamming[4:6]=data_in[1:3];
                    hamming[8:14]=data_in[4:10];
                    hamming[16:30]=data_in[11:25];
                    hamming[32:38]=data_in[26:31];
                    for (i = 1; i <= 32; i = i + 1)
                    begin
                            
                            if (i & 1)      hamming[0] = hamming[0] ^ data_in[i-1]; // P1 checks bits where bit 0 of i is 1
                            if (i & 2)      hamming[1] = hamming[1] ^ data_in[i-1]; // P2 checks bits where bit 1 of i is 1
                            if (i & 4)      hamming[3] = hamming[3] ^ data_in[i-1]; // P4 checks bits where bit 2 of i is 1
                            if (i & 8)      hamming[7] = hamming[7] ^ data_in[i-1]; // P8 checks bits where bit 3 of i is 1
                            if (i & 16)     hamming[15] = hamming[15] ^ data_in[i-1]; // P16 checks bits where bit 4 of i is 1
                            if (i & 32)     hamming[31] = hamming[31] ^ data_in[i-1]; // P32 checks bits where bit 5 of i is 1
                        end
               
                    hamming[38] = ^hamming[37:0];
                syndrome[0] = hamming[0] ^ data_in[0];
                syndrome[1] = hamming[1] ^ data_in[1];
                syndrome[2] = hamming[3] ^ data_in[3];
                syndrome[3] = hamming[7] ^ data_in[7];
                syndrome[4] = hamming[15] ^ data_in[15];
                syndrome[5] = hamming[31] ^ data_in[31];

                parity_check = ^data_in[37:0] ^ data_in[38];

                if (syndrome == 6'd0 && parity_check == 1'b0) begin
                      error = 2'b00;
                     mem[row][column]= data_in;
                     next_state =IDLE;
                end else if (syndrome != 6'd0 && parity_check == 1'b1) begin
                    corrected_word=data_in;
                    corrected_word[syndrome - 1] = ~corrected_word[syndrome - 1];
                    error = 2'b01;
                    mem[row][column]=corrected_word;
                    $display("Single bit error ,corrected while writing");
                    next_state =IDLE;
                end else if (syndrome == 6'd0 && parity_check == 1'b1) begin
                    error = 2'b10;
                     $display("Double bit error ,write halted ");
                    next_state =IDLE;
                end 
                               
                end                        
            REFRESH:
                begin
                if (refresh_mode)
                    $display("Running Adaptive Refresh (10-cycle period)");
                else
                    $display("Running Scheduled Refresh (20-cycle period)");

                // Dummy "keep-alive" loop for simulation only
                for (i = 0; i < 1024; i = i + 1)
                    for (j = 0; j < 1024; j = j + 1)
                        mem[i][j] = mem[i][j];

                next_state = IDLE;
            end
            default: 
                  next_state =IDLE;
        endcase
     end
endmodule
